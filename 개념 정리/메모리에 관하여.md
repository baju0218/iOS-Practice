값 타입 vs 참조 타입

클래스는 힙 영역에 존재

메모리 관리법 : Automatic Reference Counting == 참조 횟수를 카운팅(0되면 날림)
!= Garbage Collection



// 아래는 참조타입에만 쓰일 수 있음
strong, weak, unowned

1. strong <- default 임 얘가(keyword는 안씀)
얘가 카운팅 횟수 1 증가시킴
힙영역에 기록해놓음


2. weak
얘는 카운팅 횟수 증가 시키지 않고 ~ 힙에 없으면 nil 줌 -> 옵셔널로 선언해야함
보통 IBOutlet은 상위 뷰가 strong으로 가지고 있기 때문에 딱히 strong 안해도됨
상위 뷰 없애고 IBOutlet을 그대로 남기고 싶다면 strong으로~


3. unowned
얘도 카운팅 횟수 증가 시키지 마라
서로 참조하고 있으면 순환되서 heap에서 사라지지 않는 문제 -> 얘로 해결하기도 하고 보통 weak로 해결


///////////
클로저

클로저도 참조 타입(힙에 저장됨)
클로저 안에서 지역변수를 strong으로 캡쳐해놓으면 카운팅 효과

addUnaryOperation("√") { [ unowned me = self ] in
    me.display.textColor = UIColor.redColor()
    return sqrt($0)
}

addUnaryOperation("√") { [ weak weakSelf = self ] in
weakSelf?.display.textColor = UIColor.redColor()
    return sqrt($0)
} <- good


///////////
익스텐션

extension UIViewController {
    var contentViewController: UIViewController {
        if let navcon = self as? UINavigationController {
            return navcon.visibleViewController
        } else {
            return self
        }
    }
}

if let navcon = destination as? UINavigationController {
    destionation = navcon.visibleViewController
}


/////////////

override init <- 자식 클래스가 구현 안했으면 상속받은 init씀

required init <- 자식 클래스가 무조건 구현해야함 아님 에러
